#!/usr/bin/env perl
use strict;
use warnings;

my @paramode = ('p');

sub split_quoted {
  local ($_) = @_;
  my ($word, @words);
  $_ .= ' ';

  s/\\\s/\032/g; # Temporarily change \-whitespace to SUB characters...

  while (/\S/) {
    s/^\s*//;
    if (substr($_, 0, 1) eq '"') { ($word, $_) = split /"/, substr($_, 1), 2 }
    else { ($word, $_) = split /\s/, $_, 2 }
    $word =~ s/\032/ /g; # ...and back to unescaped spaces
    push @words, $word;
  }
  return @words;
}

sub conv_fontescape {
  local ($_) = $_[0];
  s{\\fB(.*?)\\f[PR]}{<b>$1</b>}g;
  s{\\fI(.*?)\\f[PR]}{<em>$1</em>}g;
  return $_;
}

my %special = (
  em => '&mdash;', en => '&ndash;', hy => '-',
  rg => '&reg;', co => '&copy;',
  pl => '+', mi => '&minus;', eq => '=',
  '(<' => '&lt;', '(>' => '&gt;', '(&' => '&amp;',
  '>=' => '&ge;', '<=' => '&le;', '!=' => '&ne;',
  '+-' => '&plusmn;', mu => '&times;', di => '&divide;', '**' => '&lowast;',
  '12' => '&frac12;', '14' => '&frac14;', '34' => '&frac34;',
  bu => '&bull;', de => '&deg;', dg => '&dagger;', dd => '&Dagger;',
  ua => '&uarr;', da => '&darr;', '->' => '&rarr;', '<-' => '&larr;'
#=> '&hellip;',
#=> '&ldquo;',
#=> '&rdquo;',
#=> '&lsquo;',
#=> '&rsquo;',
  );

sub conv_special {
  local ($_) = $_[0];
  s/\\-/\\(en/g;
  s/([<>&])/\\(($1/g;
  while (s/\Q\(\E(..)/$special{$1}/eg) { }
  return $_;
}

sub ignore {
  return undef;
}

my %section = ( SH => 'h1', SS => 'h2' );
sub section {
  my $level = $section{shift @_};
  return "<$level>@_</$level>";
}

sub paragraph {
  my $prefix = "";
  if ($paramode[0] eq 'dl' && $_[0] ne 'IP' && $_[0] ne '') {
    $prefix = "</dd></dl>";
    $paramode[0] = 'p';
  }
  return "$prefix<p>";
}

sub setmargin {
  unshift @paramode, 'p';
  return undef;
}

sub resetmargin {
  my $prevmode = shift @paramode;
  return ($prevmode eq 'dl')? '</dd></dl>' : undef;
}

sub definition {
  my $prefix = "</dd>";
  if ($paramode[0] ne 'dl') { $prefix = "<dl>"; $paramode[0] = 'dl'; }

  my $line = <>;
  my $term = expand_line($line);
  return "$prefix<dt>$term</dt><dd>";
}

my %font_style = ( B => 'b', I => 'em', R => undef );
sub singlefont {
  my $style = $font_style{shift @_};
  @_ = map { conv_special($_) } @_;
  return "<$style>@_</$style>";
}

sub twinfont {
  my $font = shift @_;
  my $out = "";
  for my $i (0 .. $#_) {
    my $style = $font_style{substr($font, $i % 2, 1)};
    $out .= "<$style>" if defined $style;
    $out .= conv_special($_[$i]);
    $out .= "</$style>" if defined $style;
  }
  return $out;
}

my %constant = (
  TH => undef, br => '<br>',
  );
sub constant {
  return $constant{shift @_};
}

sub table {
  my @formats = ();
  my $options = "";
  my $alignment = "";
  my $separator = "\t";
  while (<>) {
    chomp;
    my $last = 0;
    if (s/;$//) {
      $options = $_;
      $alignment = q{ align="center"} if /cent[er][re]/;
      $separator = $1 if /tab\s*\((.)\)/;
    }
    else {
      $last = 1 if s/\.$//;
      s/\s//g;
      push @formats, lc $_;
    }
    last if $last;
  }

  my $out = "<table$alignment>\n";

  while (<>) {
    chomp;
    last if /^[.']TE/;

    my ($format, $td);
    if (scalar @formats > 1) { $format = shift @formats; $td = "th" }
    else { $format = $formats[0]; $td = "td" }

    $out .= "<tr>";
    foreach (split $separator, $_) {
      s/^\s*//; s/\s*$//;

      # FIXME interpret $format
      $out .= "<$td>$_</$td>";
    }
    $out .= "</tr>\n";
  }

  $out .= "</table>";
  return $out;
}

my %request = (
  TH => \&constant, SH => \&section, SS => \&section,
  PP => \&paragraph, P => \&paragraph, IP => \&paragraph, LP => \&paragraph,
  RS => \&setmargin, RE => \&resetmargin, TP => \&definition,
  B => \&singlefont, I => \&singlefont, BI => \&twinfont, BR => \&twinfont,
  IB => \&twinfont, IR => \&twinfont, RB => \&twinfont, RI => \&twinfont,
  br => \&constant, ad => \&ignore, na => \&ignore,
  TS => \&table, '\"' => \&ignore
  );

$0 =~ s{.*/}{};

sub expand_line {
  local $_ = $_[0];
  chomp;

  if (/^[.']/) {
    @_ = split_quoted(substr($_, 1));
    if (exists $request{$_[0]}) { return $request{$_[0]}(@_) }
    else { warn "$0: unknown request '$_[0]'\n"; return undef }
  }
  elsif ($_ eq '') { return paragraph('') }
  else { return conv_fontescape(conv_special($_)) }
}

while (<>) {
  $_ = expand_line($_);
  print "$_\n" if defined $_;
}
